import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import convolve

# =================================================================
# 1. CONFIGURACIÓN Y PARÁMETROS INICIALES
# =================================================================

# Parámetros del Sistema (M-ASK)
M = 4                        # Nivel de la Modulación (4-ASK)
log2M = int(np.log2(M))      # Bits por símbolo (k=2)

# Parámetros de Tiempos y Frecuencias
Rs = 1000                    # Tasa de Símbolos (Símbolos/seg)
Tsym = 1 / Rs                # Duración de un Símbolo (seg)
fc = 10000                   # Frecuencia de la Portadora (Hz)

# Parámetros de Sobremuestreo (CRUCIAL)
Nsamp = 16                   # Muestras por símbolo
fs = Nsamp * Rs              # Frecuencia de Muestreo
Ts = 1 / fs                  # Intervalo de Muestreo

# Parámetros de Simulación
Nbits = 10000                # Total de bits a simular
Nsymbols = int(Nbits / log2M)# Total de símbolos

# Parámetros del Canal (ISI)
# Canal de ejemplo con ISI
h_isi = np.array([0.2, 1.0, 0.4]) 
h_ideal = np.array([1.0])

# Parámetros de Ruido (AWGN)
EbN0_dB = 10                 # Eb/N0 en dB
EbN0_linear = 10**(EbN0_dB / 10.0)

# =================================================================
# 2. GENERACIÓN DE SÍMBOLOS Y MAPEO
# =================================================================

# 2.1 Generación de Bits Aleatorios
bits = np.random.randint(0, 2, Nbits)

# 2.2 Mapeo M-ASK: Amplitudes [-3, -1, 1, 3] para M=4
amplitudes = np.array([-(M-1), -(M-3), (M-3), (M-1)]) 

# Conversión de bits a índices y mapeo a símbolos
bits_agrupados = bits.reshape(-1, log2M)
indices = bits_agrupados @ (2**np.arange(log2M)[::-1]) 
symbols_tx = amplitudes[indices]

# Cálculo de la Energía del Símbolo para el Ruido
Es = np.mean(symbols_tx**2)
N0 = Es / (log2M * EbN0_linear) 
sigma_ruido = np.sqrt(N0 / 2) # Desviación estándar del ruido

# =================================================================
# 3. CONFORMACIÓN DE PULSO (PULSO RECTANGULAR)
# =================================================================

# 3.1 Generar el pulso rectangular (filtro de Nsamp muestras)
rect_pulse = np.ones(Nsamp)

# 3.2 Sobremuestreo (Crea Impulsos)
symbols_up = np.zeros(Nsymbols * Nsamp) 
symbols_up[::Nsamp] = symbols_tx

# 3.3 Filtrado Rectangular (Convolución para 'expandir' los impulsos)
s_BB = np.convolve(symbols_up, rect_pulse, mode='full')
s_BB = s_BB[:Nsymbols * Nsamp] # Recortar a la longitud deseada

# Vector de tiempo
time = np.linspace(0, Nsymbols * Tsym, len(s_BB), endpoint=False)

# =================================================================
# 4. MODULACIÓN PASA BANDA
# =================================================================

carrier = np.cos(2 * np.pi * fc * time)
s_PB = s_BB * carrier

# =================================================================
# 5. CANAL Y RUIDO
# =================================================================

# Generación del ruido AWGN
ruido_awgn = sigma_ruido * np.random.randn(len(s_BB))

# A. Canal SIN Ruido NI ISI (Ideal)
r_ideal = s_BB 
# B. Canal SOLO ISI (Aplicar convolución con h_isi)
s_isi_bb = np.convolve(s_BB, h_isi, mode='same')
r_isi = s_isi_bb 
# C. Canal SOLO Ruido
r_noise = s_BB + ruido_awgn
# D. Canal Ruido E ISI
r_noise_isi = s_isi_bb + ruido_awgn

# =================================================================
# 6. DEMODULACIÓN Y MUESTREO (Filtro Adaptado Rectangular)
# =================================================================

# Filtro Adaptado óptimo para pulso rectangular
matched_filter = rect_pulse 

def demod_and_sample(r_signal, matched_filter, Nsamp):
    # 6.1 Filtro Adaptado (Convolución)
    r_matched = np.convolve(r_signal, matched_filter, mode='full')
    
    # 6.2 Recortar y alinear la señal
    delay = Nsamp - 1 
    r_matched = r_matched[delay:delay + len(r_signal)]

    # 6.3 Muestreo a Tasa de Símbolo (Decimación)
    r_sampled = r_matched[::Nsamp]
    
    return r_sampled[:Nsymbols]

# Aplicar a los 4 escenarios
constellation_ideal = demod_and_sample(r_ideal, matched_filter, Nsamp)
constellation_isi = demod_and_sample(r_isi, matched_filter, Nsamp)
constellation_noise = demod_and_sample(r_noise, matched_filter, Nsamp)
constellation_noise_isi = demod_and_sample(r_noise_isi, matched_filter, Nsamp)

# =================================================================
# 7. GRÁFICAS SOLICITADAS (CORRECCIÓN: Se elimina plt.show() intermedio)
# =================================================================

# 7.1 Formas de Onda (Solo los primeros 8 símbolos)
plt.figure(figsize=(14, 8))
N_plot = 8 * Nsamp 

plt.subplot(2, 1, 1)
# Usar plt.step para mostrar mejor el pulso rectangular
plt.step(time[:N_plot], s_BB[:N_plot], where='post', label='Banda Base (s_BB)')
plt.title('Forma de Onda Banda Base (4-ASK) - Pulso Rectangular')
plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud')
plt.grid(True, linestyle='--')

plt.subplot(2, 1, 2)
plt.plot(time[:N_plot], s_PB[:N_plot], label='Pasa Banda (s_PB)')
plt.title('Forma de Onda Pasa Banda (4-ASK)')
plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud')
plt.tight_layout()
# >>> ELIMINADO: plt.show() <<<


# 7.2 Espectros (Potencia)
# Función para calcular y graficar el espectro
def plot_spectrum(signal, fs, title):
    N = len(signal)
    Y = np.fft.fft(signal)
    P2 = np.abs(Y / N)
    P1 = P2[:N // 2]
    P1[1:-1] = 2 * P1[1:-1]
    f = fs * np.arange(N // 2) / N
    
    plt.plot(f, 10 * np.log10(P1**2))
    plt.title(f'{title} (Densidad Espectral de Potencia)')
    plt.xlabel('Frecuencia (Hz)')
    plt.ylabel('Potencia (dB)')
    plt.grid(True, linestyle='--')
    plt.xlim(0, fs / 2)

plt.figure(figsize=(14, 8))

# Espectro Banda Base
plt.subplot(2, 1, 1)
plot_spectrum(s_BB, fs, 'Espectro Banda Base (SINC² por Pulso Rectangular)')

# Espectro Pasa Banda
plt.subplot(2, 1, 2)
plot_spectrum(s_PB, fs, 'Espectro Pasa Banda')
# Limitar la vista cerca de la portadora
plt.xlim(fc - 5*Rs, fc + 5*Rs) 
plt.tight_layout()
# >>> ELIMINADO: plt.show() <<<


# 7.3 Constelaciones
fig, axes = plt.subplots(2, 3, figsize=(15, 8))
fig.suptitle('Constelaciones de M-ASK (4-ASK) con Pulso Rectangular', fontsize=16)

# Puntos de referencia ideales
ideal_points = amplitudes 

# Función auxiliar para graficar constelación
def plot_constellation(ax, data, title, color='b'):
    ax.scatter(data, np.zeros_like(data), alpha=0.5, s=20, color=color) 
    ax.scatter(ideal_points, np.zeros_like(ideal_points), marker='x', s=100, color='r', linewidth=2, label='Ideales')
    ax.set_title(title)
    ax.set_xlabel('Componente I (Real)')
    ax.set_yticks([]) # Ocultar eje Q
    ax.grid(True, linestyle='--')
    ax.axhline(0, color='gray', linewidth=0.5)
    ax.axvline(0, color='gray', linewidth=0.5)
    max_amp = np.max(np.abs(ideal_points)) * 1.5
    ax.set_xlim(-max_amp, max_amp)

# Generación de las 4 constelaciones
plot_constellation(axes[0, 0], constellation_ideal, '1. SIN Ruido NI ISI', color='g')
plot_constellation(axes[0, 1], constellation_isi, '2. Constelación con SOLO ISI', color='orange')
plot_constellation(axes[0, 2], constellation_noise, f'3. Constelación con SOLO Ruido (Eb/N0={EbN0_dB} dB)')
plot_constellation(axes[1, 0], constellation_noise_isi, '4. Constelación con Ruido E ISI')

# Rellenar espacios vacíos
axes[1, 1].axis('off')
axes[1, 2].axis('off')

plt.tight_layout(rect=[0, 0.03, 1, 0.95])

# === CORRECCIÓN CLAVE ===
# Solo se llama plt.show() una vez al final para mostrar todas las figuras.
plt.show()